# Chat App

# Table of Contents
- [Problem Statement](#problem-statement)
- [Solution Discussion](#solution-discussion)
- [Installation Instructions](#installation-instructions)
- [API Endpoints](#api-endpoints)

# Problem Statement 

It’s required to build a chat system. The system should allow creating new applications where
each application will have a token(generated by the system) and a name(provided by the client).
The token is the identifier that devices use to send chats to that application.

Each application can have many chats. a chat should have a number. Numbering of chats in
each application starts from 1 and no 2 chats in the same application may have the same
number. The number of the chat should be returned in the chat creation request.

A chat contains messages and messages have numbers that start from 1 for each chat. The number of
the message should also be returned in the message creation request. The client should never
see the ID of any of the entities. The client identifies the application by its token and the chat by
its number along with the application token.

Add an endpoint for searching through messages of a specific chat. It should be able to partially
match messages’ bodies. You must use ElasticSearch for this.

The applications table should contain a column called chats_count that contains the number of
chats for this application. Similarly, the chats table should contain a column called
messages_count that contains the number of messages in this chat. These columns don’t have
to be live. However, they shouldn’t be lagging more than 1 hour.

Assume that the system is to receive many requests. It might be running on multiple servers in
parallel and thus multiple requests may be processed concurrently. Make sure to handle race
conditions. Try to minimize the queries and avoid writing directly to MySQL while serving the
requests(especially for the chats and messages creation endpoints). You can use a queuing
system to achieve that. It is allowed for chats and messages to take time to be persisted. You
should optimize your tables by adding appropriate indices.

Your app should be containerized. We should only write `docker-compose up` to run the whole
stack

### Notes 
- You’re only asked to build the API. No GUI is required.
- You should use Ruby on Rails(V5) for building the API and the workers. BONUS: You
are encouraged to have the endpoints of chats and messages creation as a Golang app.
- The endpoints should be RESTful. You should provide endpoints for creating, updating
and reading applications, chats that belong to a specific application(GET
/applications/[application_token]/chats) and messages that belong to a specific chat.
Make sure to have appropriate indices in place for these endpoints to be optimized.
- Use MySQL as your main datastore. You’re allowed to use any other component you
need along with MySQL. You may want to check out REDIS.
- You should add a Readme containing instructions to run your code.
- BONUS: Write specs for your code.

# Solution Discussion

So as the problem stated it's required to build a chat system, we will be having 3 models within this app which are `apps`, `chats` and `messages` each of them described as following

* APP Model
- > `1:m` relation with the `Chat` model
    - token: `integer` (random number will be generated on a new record creation).
    - name: `string` (name of the application provided by the user ing the request body). 
    - chats_count: `integer` (Number of chats within this application). 
    - unique index on token.

* Chat Model
- > `1:m` relation with the `Message` model and belongs to one application
    - chat_number: `integer` (id of the chat for a specific application starts from 1 in each application an counts up). 
    - messages_count: `integer` (number of messages inside this chat).
    - application_id: `application` (The id of the parent application)
    - unique index on [app_id, chat_number]

* Message Model
- > belongs to one `Chat` model record.
    - chat_number: `integer` 
    - message_number: `integer` (id of the message for a specific chat starts from 1 for a chat and counts up)
    - content: `text` (The message body provided by the user when creating a message). 



> a chat should have a number. Numbering of chats in each application starts from 1 and no 2 chats in the same application may have the same number. The number of the chat should be returned in the chat creation request.


when creating an app, we will create a hash in redis the key is the app token for ex: "a_t_140887596" noting that the "a_t_" is a prefix and 
the token is 140887596
the value will be 0 indicating that the count of chats in this app is zero at this moment.

when creating a chat under an app token, we will retrive the value of it from redis for the past ex it is 0 so the chat number will be 0 + 1 = 1
and we will update the value in redis to be 1. (all in the same step the update and retrieval using HINCRBY)

as we did with the app, when creating a chat, we will create a hash in redis the key should be unique so it will be like this: "aid_11_cnum_714" 
where 11 is the app_id and 714 is the chat number noting that the "aid_" and "_cnum_"
the value will be 0 indicating that the count of messages in this chat is zero at this moment.

> The applications table should contain a column called chats_count that contains the number of
chats for this application. Similarly, the chats table should contain a column called
messages_count that contains the number of messages in this chat. These columns don’t have
to be live. However, they shouldn’t be lagging more than 1 hour.


Using `cron job` running every 30 minutes reading the chat_count and message_count from redis and updating our mysql db.

> Assume that the system is to receive many requests. It might be running on multiple servers in
parallel and thus multiple requests may be processed concurrently. Make sure to handle race
conditions. Try to minimize the queries and avoid writing directly to MySQL while serving the
requests(especially for the chats and messages creation endpoints). You can use a queuing
system to achieve that. It is allowed for chats and messages to take time to be persisted.

using `Sidekiq` the creation of messages and chats in the mysql db will be handled as background jobs.

> Your app should be containerized. We should only write `docker-compose up` to run the whole
stack

we will have 6 services in `docker-compose.yml`.
1- redis
2- mysql
3- elastic search
4- cron jobs
5- sidekiq
6- api (our main app)

We seperate the cron jobs in seperate server to avoid repeating jobs
when scalling the main app horizontally.

# Installation Instructions

Just run

```sh
docker-compose up
```

# API Endpoints 

The APIs will be listening on port `4000` 
Please check file 
```sh
requests.http
```
it has all the APIs and you can call them from their.